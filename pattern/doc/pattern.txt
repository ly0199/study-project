
类加载顺序：
    先静态、后动态
    先属性、后方法
    先上、后下


单例模式
    一个类模板，在整个系统运行过程中，只允许产生一个实例（有且只有一个）
    解决一个并发访问的时候线程安全问题
    保证单例的技术方案有多种：
        饿汉式、懒汉式、注册登记式、枚举式。
        序列化于反序列化的时候出现多例

    饿汉式：在实例使用之前，不管你用不用，我都先new出来再说，避免线程安全问题
    懒汉式：默认加载的时候不加载，当需要的时候加载
    延时加载

    注册登记式：每使用一次，都往一个固定的容器中去注册并且将使用过的对象进行缓存，
               下次去取对象的时候，就直接从缓存中取值，以保证每次获取的都是同一对象。
        IOC中的单例模式，就是典型的注册登记式单例

    序列化与反序列化保证单例：重写readResolve() 序列化时重写可以保证唯一


原型模式
    DTO, VO, POJO, Entity
    之间存在一些熟悉名称，类型都相同

    数据库中表查询出来的对象会赋值给DTO
    MVC中的Model
    把DTO中的值会赋值给VO
    再把VO中的值传输到View中去

    复制：要把DTO中的每一个属性的值赋值给VO中的每一个属性
         属性名称相同，属性类型相同

    Apache BeanUtils 反射区实现（原型模式）
    clone()

    scope="prototype" 把对象中配置的依赖关系，在每次使用对象之前都会创建一个新的对象
                      并且会将依赖关系完整的赋值给这个新创建的对象

    Spring默认是单例模式